---
layout: post
title: Java数据结构与基础算法（书）
date: 2021-06-19 23:18 +0800
last_modified_at: 2022-05-31 00:00:00 +0800
tags: [Base, Java, algorithm]
toc:  true
---

# Java数据结构与基础算法

> 2021年3月末被第一家公司裁员，稀里糊涂干了半年后端开发，然后来到第二家，也是个小公司，在这学习了很多，公司很小，大佬很多。有充足的时间学习，忙里抽闲看完了这本Java数据结构与算法，有很多图在复制时丢掉了，所以我就再也不用本地笔记了。
> 这本书算是程序员必修课本之一，其中的解题思路很好。作者是外国人。

### 1 概述

1.1 软件质量

|质量特征|描述|
|-|-|
|正确性|软件在大多程度上满足其特定的需求|
|可靠性|软件故障发生的频率和危险程度|
|健壮性|出错情况下可以得到恰当处理的程度|
|可用性|用户学习和执行任务的难易程度|
|可维护性|对软件进行修改的难易程度|
|可重用性|软件组件可重用于其他软件系统开发的难易程度|
|可移植性|软件组件可以在多个计算机环境下使用的难易程度|
|运行效率|在不浪费资源的情况下软件完成其目标的程度|


### 2 算法分析

渐进复杂度--O，与问题大小无关，如O(n)，（而不会写做O(15n)）

固定时长则写为O(1)，不管问题大小，运行赋值语句和if语句一次，其复杂度就为O(1)，因此无论多少个if其复杂度都为O(1)，只是主管可读性上的问题。

**增长函数和渐进复杂度**

|增长函数|阶次|标记/阶次|
|-|-|-|
|t(n) = 17|O(1)|常量型|
|t(n) = 3log n|O(log n)|对数型|
|t(n) = 20n - 4|O(n)|线性|
|t(n) = 12n log n + 100n|O(n log n)|n log n|
|t(n) = 3n^2 + 5n - 2|O(n^2)|平方型|
|t(n) = 8n^3 + 3n^2|O(n^3)|立方型|
|t(n) = 2^n + 18n^2 + 3n|O(2^n)|指数型|


假设某个循环复杂度为O(1)，那么循环的时间复杂度为O(n)

如果双重循环，内层循环体的复杂度为O(1)，则复杂度为O(n^2)，需要相乘

比如经典求和示例。

> sum和sum2 的执行结果相同，因为算法不同，方法复杂度分别为O(n) 和 O(1)，sum2的效率要高

```java
public void sum(int count) {
        long sum = 0;
        for (int i = 1; i <= count; i++) {
            sum += i;
        }
        System.out.println(sum);
    }

public void sum2(int count) {
        long sum = (count * (count + 1)) / 2;
        System.out.println(sum);
}

```

### 3 集合概述——栈

集合是一种聚集、组织了其他对象的对象。（注意，Stack类已经过时）

集合可以分两大类：线性集合（元素按直线方式组织）、非线性集合（如层次组织或网状组织）

抽象数据类型ADT（Abstract Data Type)，ADT必须对其实现细节进行定义，且这些对用户是不可兼得。集合就是一种抽象数据类型

**栈集合**

LIFO后进先出，栈是一种线性集合（栈的基本使用就是用于颠倒顺序，如撤销操作）

Stack，常用操作push（添加）、pop（移除顶部）、peek（查看顶部）

中缀表达式：通常计算方式

```java
<操作数> <操作符> <操作数>
如：4 + 5
```

后缀表达式：不用考虑优先级和括号，程序设计语言编译器运行时环境的内部计算使用。（不推荐学习使用），从左到右扫描，遇到*号将操作符应用到之前两个操作数

```java
<操作数> <操作数> <操作符>
如：9 4 -
// 结果为5
如（3 * 4 -（2 + 5）） * 4 / 2
等价后缀：
3 4 * 2 5 + - 4 * 2 /
12 2 5 + - 4 * 2 /
12 7 - 4 * 2 /
5 4 * 2 /
20 2 / 
10
```

利用栈来计算后缀表达式算法描述如下：

> 1、从左到右扫描表达式，依次标识出每个符号（操作符或操作数）
2、如果是操作数，则把它压入栈中。如果是操作符，则从栈中弹出两个元素，并把该操作符应用在这两个元素之上，然后把操作结果压入到栈中。
3、当到表达式的末尾时，栈中所有剩余的元素就是该表达式的结果。
4、如果试图从栈中弹出两个元素时，该栈中并没有，那么该后缀表达式是不正确的。同样，如果到达表达式结尾时，栈中剩余的元素不止一个，那么也是不正确的。

创建泛型数组

```java
private T[] stack = (T[]) (new Object[DEFAULT_CAPACITY]);
// 或者
@SuppressWarnings({ "unchecked", "hiding" })
public <T>  T[] getArray(Class<T> componentType,int length) {
      return (T[]) Array.newInstance(componentType, length);
}
```

自定义一种数组栈

```java
 /**
    使用数组实现栈
    1、该数组是一个对象引用的数组，使用泛型，数据类型再栈实列化时确定。
    2、栈底总是在数组的索引0处
    3、栈的元素是按顺序并连续的存储在数组中
    4、有一个整数变量top，该变量保存了紧跟栈顶元素后的数组索引号（既表示了下一个单元要存储的位置，也表示了当前栈中的元素数量）
    _____________________________
    | A  | B  | C  | D  | top |
    —————————————————————————————

    泛型数组必须由Object引用来创建

     */
    @SuppressWarnings("enchecked")
    public class ArrayStack<T> implements StackADT<T> {
        
        @Override
        public String toString() {
            return "ArrayStack{" +
                    "DEFAULT_CAPACITY=" + DEFAULT_CAPACITY +
                    ", top=" + top +
                    ", stack=" + Arrays.toString(stack) +
                    '}';
        }

        private final int DEFAULT_CAPACITY = 100;

        private int top;
        private T[] stack;

        // 底层使用的是new Obj
        public ArrayStack() {
            top = 0;
            stack = (T[]) (new Object[DEFAULT_CAPACITY]);
        }

        public ArrayStack(int initialCapacity) {
            top = 0;
            stack = (T[]) (new Object[initialCapacity]);
        }

        // 另一种方法
        @SuppressWarnings({ "unchecked", "hiding" })
        public <T>  T[] getArray(Class<T> componentType,int length) {
            return (T[]) Array.newInstance(componentType, length);
        }

        @Override
        public void push(T element) {
            if (size() == stack.length) {
                expandCapacity();
            }
            stack[top] = element;
            top++;
        }

        @Override
        public T pop() {
            if (isEmpty()) {
                throw new EmptyCollectionException("Stack");
            }
            top--;
            T result = stack[top];
            stack[top] = null;
            return result;
        }

        @Override
        public T peek() {
            if (isEmpty()) {
                throw new EmptyCollectionException("Stack");
            }
            return stack[top - 1];

        }

        @Override
        public boolean isEmpty() {
            return false;
        }

        @Override
        public int size() {
            return 0;
        }

        /**
         * 扩容机制就是赋值一个，然后长度·变为2倍。
         */
        private void expandCapacity() {
            stack= Arrays.copyOf(stack, stack.length * 2);
        }
    }

    public interface StackADT<T> {
        /**
         * 1、确保该数组不是满的；2、把数组的top引用设置为要加入栈中的对象；3、增加top值
         * @param element 元素
         */
        void push(T element);

        /**
         * 1、确保栈不为空；2、减少top计数器；3、设置一个临时引用等于stack[top]的元素
         * 4、设置stack[top]为空；5、返回该临时引用
         * 所有步骤复杂度都为 O(1)，这样pop方法的复杂度为O(1)
         * @return 栈数组
         */
        T pop();

        /**
         * 查看顶部元素
         * @return 返回top-1的元素
         */
        T peek();
        boolean isEmpty();
        int size();
    }

    public static class EmptyCollectionException extends RuntimeException{
        public EmptyCollectionException(String collection) {
            super("集合" + collection + "为空");
        }
    }
```

### 4 链式结构——栈

链式结构：它使用对象引用变量来创建对象之间的链接。

链表由一些对象构成，其中每个对象指向了链表中的下一对象。

链表会按需动态扩张，是一种动态结构，java中所有动态创建的对象都来自于**系统堆**或自由存储内存区。

集合基本作用是添加，删除，访问元素。

链表访问元素：一个一个走，判断是否相等，不然就下一个。

链表添加元素：改变引用顺序。插入节点的尾巴指向当前的头，前面的尾巴指向插入的头，链表的首节点需要特别注意。

链表删除：如果要删除首节点，需要重新指向链表前端的引用，使前端引用指向当前的第二个节点。

**双向链表**

哨兵节点：位于链表的头或尾，起标记符作用，不表示链表中的某个元素

可以使用栈来模拟递归处理，以跟踪恰当的数据。

自定义链表栈

```java
public class LinearNode<T> {
    private LinearNode<T> next;
    private T element;

    public LinearNode() {
        next = null;
        element = null;
    }

    public LinearNode(T elem) {
        next = null;
        element = elem;
    }

    public LinearNode<T> getNext() {
        return next;
    }

    public void setNext(LinearNode<T> node) {
        next = node;
    }

    public T getElement() {
        return element;
    }

    public void setElement(T element) {
        this.element = element;
    }
}

public class LinkedStack<T> implements StackADT<T> {

    // 在栈中存储的元素的数量
    private int count;

    /**
     * 指向栈顶的指针，将链表前端作为栈顶，就不用每次都遍历链表。
     */
    private LinearNode<T> top;

    /**
     * 构造函数把元素计数设置为0，并设置了链表的前端结点（top表示）为null，且无需担心扩容
     */
    public LinkedStack() {
        count = 0;
        top = null;
    }

    @Override
    public void push(T element) {
        //创建一个新结点，该结点含有一个引用，指向要放置到栈中的对象。
        LinearNode<T> temp = new LinearNode<>(element);
        //把新结点的next引用设置为指向当前栈顶（如果栈为空，那它就是null)。
        temp.setNext(top);
        //把top 引用设置为指向该新结点。
        top = temp;
        //递增栈的元素计数。
        count++;
    }


    @Override
    public T pop() {
        //确保栈不为空。
        if (isEmpty()) {
            throw new ArrayTest.EmptyCollectionException("Stack");
        }
        //设置一个临时引用等于栈顶元素。
        T result = top.getElement();
        //设置top 引用等于栈顶结点的next引用。递减栈的元素计数。
        top = top.getNext();
        count--;
        return result;
    }

    @Override
    public T peek() {
        //确保栈不为空。
        if (isEmpty()) {
            throw new ArrayTest.EmptyCollectionException("Stack");
        }
        return top.getElement();
    }

    @Override
    public boolean isEmpty() {
        return false;
    }

    @Override
    public int size() {
        return 0;
    }
}
```

一个Node元素有2个指针，指向下一个节点的指针，指向当前自身节点的对象的引用

### 5 队列

先进先出。

enqueue，向队列末端添加一个元素

dequeue，向队列前端删除一个元素

first，查看队列前端的那个元素

JavaApi中使用Queue接口。

> add和remove会返回异常，offer和poll会返回false和null

栈主要颠倒顺序，而队列是保持顺序。

**重复密钥**加密（这种密钥也比较容易破解）

使用一个密钥值列表，将各个字母移动不同的位数（移动相同的位数方法叫凯撒加密），文本长度超过密钥值时则循环密钥值。如：

> 密钥值为：123456，明文为：hello world
密文为：igopt....

使用队列实现重复密钥加密

```java
package com.miaski.study.datastructure.collection;
import java.util.LinkedList;
import java.util.Queue;
/**
 * @author bfq
 */
public class CodesQueue {

    public static void main(String[] args) {
        int[] key = {5, 12, -3, 8, -9, 4, 10};
        Integer keyValue;
        StringBuilder encoded = new StringBuilder();
        StringBuilder decoded = new StringBuilder();
        String message = "talk is cheap, show me code.";
        Queue<Integer> encodingQueue = new LinkedList<>();
        Queue<Integer> decodingQueue = new LinkedList<>();
        // 装载
        for (int value : key) {
            encodingQueue.add(value);
            decodingQueue.add(value);
        }
        // 加密
        for (int i = 0; i < message.length(); i++) {
            keyValue = encodingQueue.remove();
            encoded.append((char) (message.charAt(i) + keyValue));
            encodingQueue.add(keyValue);
        }
        System.out.println("加密信息为：" + encoded);

        // 解密
        for (int i = 0; i < encoded.length(); i++) {
            keyValue = decodingQueue.remove();
            decoded.append((char) (encoded.charAt(i) - keyValue));
            decodingQueue.add(keyValue);
        }
        System.out.println("解密信息为：" + decoded);

    }
}

```

使用队列实现售票

```java
package com.miaski.study.datastructure.collection;
import java.util.LinkedList;
import java.util.Queue;
/**
 * @author bfq
 */
public class TicketCounter {

    /** 处理时间 */
    final static int PROCESS = 120;
    /** 最大售票口 */
    final static int MAX_CASHIER = 10;
    final static int NUM_CUSTOMERS = 10000;

    /**
     * 模拟100个人，买票，当售票口为8时，顾客不用等待，这个有bug
     */
    public static void main(String[] args) {
        Customer customer;
        Queue<Customer> customerQueue = new LinkedList<>();
        int[] cashierTime = new int[MAX_CASHIER];
        int totalTime;
        long averageTime;
        int departs;
        int start;

        for (int cashiers = 0; cashiers < MAX_CASHIER; cashiers++) {
            for (int count = 0; count < cashiers; count++) {
                cashierTime[count] = 0;
            }
            for (int count = 1; count <= NUM_CUSTOMERS; count++) {
                customerQueue.offer(new Customer(count * 15));
            }
            totalTime = 0;

            while (!(customerQueue.isEmpty())) {
                for (int count = 0; count <= cashiers; count++) {
                    if (!(customerQueue.isEmpty())) {
                        customer = customerQueue.remove();
                        if (customer.getArrivalTime() > cashierTime[count]) {
                            start = customer.getArrivalTime();
                        }else {
                            start = cashierTime[count];
                        }
                        departs = start + PROCESS;
                        customer.setDepartureTime(departs);
                        cashierTime[count] = departs;
                        totalTime += customer.totalTime();
                    }
                }
            }
            averageTime = totalTime / NUM_CUSTOMERS;
            System.out.println("售票口数量：" + (cashiers + 1));
            // 在7个口时，速率一定，时间一定
            System.out.println("平均时间" + averageTime);
        }

    }

    static class Customer{
        private int arrivalTime;
        private int departureTime;

        public Customer(int arrives) {
            arrivalTime = arrives;
            // 从0开始
            departureTime = 0;
        }
        public int getArrivalTime() {
            return arrivalTime;
        }
        public void setArrivalTime(int arrivalTime) {
            this.arrivalTime = arrivalTime;
        }
        public int getDepartureTime() {
            return departureTime;
        }
        public void setDepartureTime(int departureTime) {
            this.departureTime = departureTime;
        }
        
        public int totalTime() {
            return departureTime - arrivalTime;
        }
    }
}
```

使用链表实现队列

> 对于单向链表，在末端入列前端出列时，只需设置一个临时变量指向链表前端的元素，然后把front变量设置为第一个节点的next指针值，复杂度为O(n)。但如果在前端入列后端出列，那么deq复杂度就是O(n)，因为出列需要遍历链表。

```java
/**
 * 使用链表实现队列
 * @author bfq
 */
public class LinkedQueue<T> implements QueueADT<T> {

    private int count;
    private LinearNode<T> head;
    private LinearNode<T> tail;

    public LinkedQueue() {
        count = 0;
        head = tail = null;
    }

    @Override
    public void enqueue(T element) {
        LinearNode<T> node = new LinearNode<>(element);
        if (isEmpty()) {
            head = node;
        }else {
            tail.setNext(node);
        }
        tail = node;
        count++;
    }

    @Override
    public T dequeue() {
        if (isEmpty()) {
            throw new ArrayTest.EmptyCollectionException("queue");
        }
        T result = head.getElement();
        head = head.getNext();
        count--;
        if (isEmpty()) {
            tail = null;
        }
        return result;
    }
}
```

数组实现队列很低效，为O(n)，每次添加元素都要循环遍历。

可以使用**环形数组**来实现队列

双端队列Deque

允许队列两端添加、删除、查看。

> （推荐使用Deque来替代Stack，因为Stack继承Vector且加入了synchronized，基于数组，效率不如Deque）

### 6 列表

列表（list）和链表（linked）区别

链表是一种实现策略，使用引用来在对象之间创建链接。可以用链表来分别实现栈和队列集合。

列表集合是一种概念性表示法，其思想是使事物以线性列表的方式进行组织。就像栈和队列一样，列表也可以使用链表或数组来实现。列表集合没有内在的容量大小，它可以随着需要而增大。
栈和队列都是线性结构，其元素只能在末端添加和删除。列表集合可以在列表的中间和末端添加和删除元素。

列表分三类：有序列表（元素具有内在关联），无序列表（使用者可以决定顺序），索引列表。

索引列表和数组区别：索引列表的索引值总是连续的，删除新增时索引都会位移。

List接口主要方法：add(E)，add(index，E)，get(index)，remove(index)，remove(E)，set(index, E)【替代指定索引处的元素】，size()

使用无序列表（linkedList）实现学习计划，Serializable接口表示对象能能使用串行化进行存储

```java
public class ProgramOfStudy implements Iterable<Course>, Serializable{

    public static void main(String[] args) throws IOException {
        ProgramOfStudy pos = new ProgramOfStudy();
        pos.addCourse(new Course("CS-GO", 101, "介绍编程", "A-"));
        pos.addCourse(new Course("ARCH", 305, "构建分析", "A"));
        pos.addCourse(new Course("GER", 211, "Intermediate German"));
        pos.addCourse(new Course("CS", 320, "计算机技术"));
        pos.addCourse(new Course("THE", 201, "歌剧表演"));

        Course arch = pos.find("CS", 320);
        pos.addCourseAfter(arch,new Course("CS",321, "操作系统"));

        Course theatre = pos.find("THE", 201);
        theatre.setGrade("A-");

        Course ger = pos.find("GER", 211);
        pos.replace(ger, new Course("FRE", 110,"基础法语", "B+"));

        System.out.println(pos);

        pos.save("ProgramOfStudy-file");
    }




    private List<Course> list;

    public ProgramOfStudy() {
        list = new LinkedList<Course>();
    }

    public void addCourse(Course course) {
        if (course != null) {
            list.add(course);
        }
    }

    public Course find(String prefix, int number) {
        for (Course course : list) {
            if (prefix.equals(course.getPrefix()) && number == course.getNumber()) {
                return course;
            }
        }
        return null;
    }

    public void addCourseAfter(Course target, Course newCourse) {
        if (target == null || newCourse == null) {
            return;
        }
        int targetIndex = list.indexOf(target);
        if (targetIndex != -1) {
            list.add(targetIndex + 1, newCourse);
        }
    }

    public void replace(Course target, Course newCourse) {
        if (target == null || newCourse == null) {
            return;
        }
        int targetIndex = list.indexOf(target);
        if (targetIndex != -1) {
            list.set(targetIndex, newCourse);
        }
    }

    @Override
    public String toString() {
        StringBuilder result = new StringBuilder();
        for (Course course : list) {
            result.append(course).append("\n");
        }
        return result.toString();
    }

    /**
     * 对象流
     */
    public void save(String fileName) throws IOException {
        FileOutputStream fos = new FileOutputStream(fileName);
        ObjectOutputStream oos = new ObjectOutputStream(fos);
        oos.writeObject(this);
        oos.flush();
        oos.close();
//        FileUtils.writeStringToFile();
    }

    public static ProgramOfStudy load(String fileName) throws IOException, ClassNotFoundException {
        FileInputStream fis = new FileInputStream(fileName);
        ObjectInputStream ois = new ObjectInputStream(fis);
        ProgramOfStudy pos = (ProgramOfStudy) ois.readObject();
        ois.close();
        return pos;
    }

    @Override
    public Iterator<Course> iterator() {
        return list.iterator();
    }
}    
```

> Josephus问题：
Flavius Josephus是公元1世纪的犹太历史学家。传说他是41个被捕后宁愿自杀也不愿向罗马屈服的犹太叛逆者之一。他们决定排成一圈，然后每数3个人就自杀一人，直到剩下一个。Josephus并不想死，他计算出了他应该站的位置，那样他就可以活到最后一个，就不用去死了。由此诞生了一类问题，称为Josephus问题。这类问题着眼于，当列表中的事件不是按顺序取出而是按每隔i个元素提取，直到一个不剩时，如何找到这些事件的顺序。

索引列表使用示例。

```java
public static void main(String[] args) {
        int numPeople;
        int skip;
        int targetIndex;
        List<String> list = new ArrayList<>();

        Scanner scanner = new Scanner(System.in);
        System.out.println("请输入待处决人数：");
        numPeople = scanner.nextInt();
        scanner.nextLine();
        System.out.println("请输入处决间隔：");
        skip = scanner.nextInt();
        targetIndex = skip;

        for (int i = 1; i <= numPeople; i++) {
            list.add("人员" + i);
        }

        System.out.println("处决顺序是：");
        while (!list.isEmpty()) {
            System.out.println(list.remove(targetIndex));
            if (list.size() > 0) {
                // 核心代码
                targetIndex = (targetIndex + skip) % list.size();
            }
        }
    }
```

自定义列表实现在113页

### 7 迭代器

在Java API 中，迭代器是使用如下两个基本接口来实现的。
Iterator：用于定义一个对象，该对象用作为一个迭代器。

三个方法：hasNext()，next()，remove()

Iterable：用于定义一个集合，从该集合中可以抽取出一个迭代器。

一个方法：Iterator iterator()	【返回作用于E类型的元素集上的迭代器】

当只想处理迭代中的某些元素（而不是全部）那就会使用显示迭代器，找到后跳出循环。

> 迭代器的remove方法使得它可以删除一个元素，而无需再次遍历集合

迭代器大多是fail-fast，在使用中如果修改集合，则会抛出异常。

使用数组实现迭代器时需要注意

```java
private boolean hasNext() throws xxxException{
    if (iteratorModCount != modCount) {
        thr new exception();
    }
    return current < rear;
}
```

使用链表实现迭代器。同样也需要定义内部私有类。外部类维护modCount和内部迭代器值一致

### 8 递归

递归的定义本身就是递归自己，比如：定义一个数字列表，可以是[数字，数字列表]，那数字列表又可以是[数字，数字列表]。。。如果按照这种解释的话，这种叫做**无穷递归**，是一种死循环。

> 任何递归必须要有一个非递归部分（基本情形），使得递归最终会终止

阶乘，一种递归的数学表达式

```java
N! = 1 * 2 * 3 * .... * N
// 也可以写作，N>1，应考虑N<1 N=1 和 N>1三种情况
N! = N*(N-1)!
```

该定义的基本情形时 1！，1！被定义为1。所有其他的N！值都递归定义成（N-1）！的N倍。

> 比如：5！ =  5 * 4！
4！ =  4 * 3！
3！ = 3 * 2！
！就是一种递归 ，最终终止在1！，1！就是基本情形

如：求和的递归写法。

```java
public int sum3(int num) {
        int result;
        if (num == 1) {
            result = 1;
        }else {
            result = num + sum3 (num - 1);
        }
        return result;
    }
```

假设输入4，则第一次调用时会递归第一次，第一次中有需要递归第二次，一直递归到最后，然后在**基本情形**下得到结果，开始返回带入到倒数第二次的递归，一直向前带入，最终返回第一次递归。

> 递归的使用是相对的，对于某些问题是最优解，对于另一些问题则没有迭代解法直观

**直接递归**：自己调自己，M => M

**间接递归**：M => M1 => M2 => M ....，间接递归尽量避免，十分复杂难以跟踪。

使用递归场景：不断尝试，试探，套娃。

#### 迷宫

如：穿越迷宫递归解法（原代码少一行边界值判断）

```java
package com.miaski.study.datastructure;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

/**
 * @author bfq
 */
public class Maze{
    /**
     * 标记
     */
    private static final int TRIED = 2;
    /**
     * 路径
     */
    private static final int PATH = 3;
    private int numberRows;
    private int numberColumns;
    private int[][] grid;

    public Maze(String filename) throws FileNotFoundException {
        Scanner scanner = new Scanner(new File(filename));
        numberRows = scanner.nextInt();
        numberColumns = scanner.nextInt();

        grid = new int[numberRows][numberColumns];
        for (int i = 0; i < numberRows; i++) {
            for (int j = 0; j < numberColumns; j++) {
                grid[i][j] = scanner.nextInt();
            }
        }
    }
    /**
     * 标记尝试位置
     */
    public void tryPosition(int row, int col) {
        grid[row][col] = TRIED;
    }
    /**
     * 获取行数
     */
    public int getRows() {
        return grid.length;
    }
    /**
     * 获取列数
     */
    public int getColumns() {
        return grid[0].length;
    }
    /**
     * 标记最终路径
     */
    public void markPath(int row, int col) {
        grid[row][col] = PATH;
    }
    /**
     * 验证位置正确性
     */
    public boolean validPosition(int row, int column) {
        boolean result = false;
        // 检查格子是否在矩阵中
        if (row >= 0 && column < grid[row].length) {
            // 检查单元格是否未被阻塞，是否未尝试过
            if (grid[row][column] == 1) {
                result = true;
            }
        }
        return result;
    }

    @Override
    public String toString() {
        String result = "\n";
        for (int row = 0; row < grid.length; row++) {
            for (int column = 0; column < grid[row].length; column++) {
                result += grid[row][column] + "";
            }
            result += "\n";
        }
        return result;
    }
}

//解析器
package com.miaski.study.datastructure;

import java.io.FileNotFoundException;
import java.util.Scanner;

/**
 * @author bfq
 */
public class MazeSolver {

    public static void main(String[] args) throws FileNotFoundException {
        Scanner scanner = new Scanner(System.in);
        System.out.println("输入带有maze的文件名");
        String filename = scanner.nextLine();
        Maze labyrinth = new Maze(filename);

        System.out.println(labyrinth);

        MazeSolver solver = new MazeSolver(labyrinth);

        if (solver.traverse(0, 0)) {
            System.out.println("迷宫解析成功");
        }else {
            System.out.println("没有可用路径");
        }
        System.out.println(labyrinth);
    }

    private Maze maze;

    public MazeSolver(Maze maze) {
        this.maze = maze;
    }

    public boolean traverse(int row, int column) {
        boolean done = false;

        if (maze.validPosition(row, column)) {
            maze.tryPosition(row, column);
            // 标记这个格子已经尝试过

            if (row == maze.getRows() - 1 && column == maze.getColumns() - 1) {
                done = true;
            }else {
                // down 下标越界问题
                if ((row != maze.getRows() - 1)) {
                    done = traverse(row + 1, column);
                }
                if (!done) {
                    //right
                    done = traverse(row, column + 1);
                }
                if (!done) {
                    //up
                    done = traverse(row - 1, column);
                }
                if (!done) {
                    //left
                    done = traverse(row, column - 1);
                }
            }
            // 这个坐标是最终路径
            if (done) {
                maze.markPath(row, column);
            }
        }
        return done;
    }
}

```

#### 汉诺塔

三个柱子，将初始柱子的金字塔型的圆盘移动至第三根柱子上，每次只能移动一个盘，大盘不能在小盘上，除了正在移动的盘其他盘必须在柱子上。

> 三步策略：将最上方N-1张圆盘从最初柱子移动到中间柱子
将最大的盘从初始柱子移动到右边柱子
再将那根多出的柱子上N-1张圆盘移动到最终的柱子上。

（3个盘子移动7次，4个盘子移动15次，5个盘子31次）

代码如下

```java
package com.miaski.study.datastructure;

/**
 * hanoi problem
 * @author bfq
 */
public class TowersOfHanoi {

    public static void main(String[] args) {
        TowersOfHanoi towers = new TowersOfHanoi(5);
        towers.solve();
        System.out.println("移动了" + count + "次");
    }

    private int totalDisks;
    private static int count;

    public TowersOfHanoi(int totalDisks) {
        this.totalDisks = totalDisks;
    }

    /**
     * 将盘从柱子1移动到柱子3，使用2号作为临时柱
     */
    public void solve() {
        moveTower(totalDisks, 1, 3, 2);
    }

    private void moveTower(int numDisks, int start, int end, int temp) {
        count++;
        if (numDisks == 1) {
            moveOneDisk(start, end);
        }else {
            moveTower(numDisks - 1, start, temp, end);
            moveOneDisk(start, end);
            moveTower(numDisks - 1, temp, end, start);
        }
    }

    private void moveOneDisk(int start, int end) {
        System.out.println("移动顶盘，从" + start + "到" + end);
    }

}

```

> 第一次调用 1， 3， 2：所有盘都要从第一个柱子移动到第三个柱子
moveTower方法首先考虑基本情形（仅含一张圆盘的“圆盘叠”)。
出现基本情形时，moveTower会调用moveOneDisk方法,
而moveOneDisk方法会打印出一行表明这次特定移动。
如果圆盘叠含有多张圆盘，则会再次调用moveTower
以便取出“挡道的”N一1张圆盘，接着再移动最大的那张圆盘，
然后再由另一次moveTower调用将那N一1张圆盘移到它们最终的位置。

这代码写的真牛逼

汉诺塔增长函数为f(n) = 2*(f(n+1)+1) = 2^n - 1，复杂性为O(2^n)

**递归算法分析**

对于累加和递归运算，因为递归方法体执行了一次加法，于是其复杂性为O(1)。每次调用递归方法时，num的值都会递减1。因此，这个递归方法被调用num次，于是递归的序为O(n)。这样，由于方法体的复杂性为O(1)、递归的复杂性为O(n)，所以整个算法的序为O(n)。

我们还可看到，在有些算法中，递归步骤的运算数据只是上一次调用的一半，这时得到递归的序为O(log n)。如果方法体的复杂性是O(1)，则整个算法的复杂性为O(log n)。如果方法体的复杂性是O(n)，则整个算法的复杂性为O(n log n)。

### 9 排序与查找

**泛型方法**

创建一个泛型方法，只需在方法头的返回类型前插入一个泛型声明即可。

```java
public static <T extends Comparable<T>> boolean linearSearch(T[] data, int min, int max, T target) {}
```

#### 线性查找

从一端开始逐个查找比对，实现如下

```java
/**
     * 线性查找方法
     * @param data 原数组
     * @param min 起始
     * @param max 终点
     * @param target 目标对象
     * @param <T> 泛型
     * @return 是否找到，或者也可以写作返回该元素。
     */
    public static <T extends Comparable<T>> boolean linearSearch(T[] data, int min, int max, T target) {
        int index = min;
        boolean found = false;
        while (!found && index <= max) {
            if (data[index].compareTo(target) == 0) {
                found = true;
            }
            index++;
        }
        return found;
    }
```

效率不是很高，复杂度O(n)

#### 二分查找

如果查找池中的项目组是已排序的，那可以用二分查找法。【每次比较都会删除一半的可行候选项】

```java
 /**
     * 二分查找法
     */
    public static <T extends Comparable<? super T>> boolean binarySearch (T[] data, int min, int max, T target) {
        boolean found = false;
        int midpoint = (min + max) / 2;
        // 使用中点去比较
        if (data[midpoint].compareTo(target) == 0) {
            found = true;
        }else if (data[midpoint].compareTo(target) > 0) {
            // 大于目标
            if (min <= midpoint -1) {
                // 还在前半段中
                found = binarySearch(data, min, midpoint -1, target);
            }
        }else if (midpoint + 1 <= max) {
            found = binarySearch(data, midpoint + 1, max, target);
        }
        return found;
    }
```

时间复杂度O(log2n)，大概会比较(log2n)/2次

**排序**

顺序排序（嵌套循环对n个元素排序，大约要比较n^2次）

对数排序（类似二分，大约要nlog2n次比较）

#### 选择排序

选择排序( selection sort〉算法通过反复地将某一特定值放到它在列表中的最终已排序位置，从而完成对某一列值的排序。换句话说，对于列表中的每一位置，该算法都将选择出应该放进这一位置的值并将其放在那里。

> 选择排序算法的一般策略如下:扫描整个列表以找出最小值。将这个值与该列表第一个位置处的值交换。扫描（除了第一个值的）剩余部分列表并找出最小值，然后将它和该列表第二个位置处的值交换。扫描（除了前两个值的）剩余部分列表并找出最小值，然后将它和该列表第三个位置处的值交换。对列表中每一位置继续该过程。当这一过程结束后，列表也就已排好序了。

代码实现（从小到大，改为>则反之）

```java
public static <T extends Comparable<? super T>> void selectionSort(T[] data) {
        int min;
        T temp;
        for (int index = 0; index < data.length - 1; index++) {
            min = index;
            // 遍历当前位后面的
            for (int scan = index + 1; scan < data.length; scan++) {
                // 如果后面对比前面的小，最小值的下标为当前下标
                if (data[scan].compareTo(data[min]) < 0) {
                    min = scan;
                }
            }
            // 交换值
            temp = data[min];
            data[min] = data[index];
            data[index] = temp;
        }
    }
```

#### 插入排序

插入排序（ insertion sort）算法通过反复地将某一特定值插入到该列表某个已排序的子集中来完成对列表值的排序。每次一个，每一个未排序元素都被插入到这个已排序子集的恰当位置处，直至整个列表排好序。

> 插入排序算法的一般策略如下:对列表中的头两个值依据其相对大小对其进行排序，如果有必要则将它们互换。将列表的第三个值插入到头两个(已排序的)值中的恰当位置。然后将第四个值插入到列表头三个值中的正确位置。每做出一次插入，该排序子集中的值数目就会增加一个。继续这一过程，直至列表中的所有元素都得到完全排序。该插入过程需要对数组中的其他元素移位，以给插入元素腾出空间。图9.4展示了该插入过程。

实现如下

```java
/**
 * 插入排序
 */
public static <T extends Comparable<? super T>> void insertionSort(T[] data) {
    // 注意从1开始，也就是第二位
    for (int index = 1; index < data.length; index++) {
        T key = data[index];
        int position = index;
        // shift larger values to the right，注意这里用的key
        while (position > 0 && data[position - 1].compareTo(key) > 0) {
            // 向后位移
            data[position] = data[position - 1];
            position--;
        }
        // key的作用相当于交换
        data[position] = key;
    }
}
```

#### 冒泡排序

冒泡排序法(bubble sort）是另一种使用了两个嵌套循环的顺序排序算法。它通过重复比较列表中的相邻元素，并在它们彼此不符顺序时将它们互换来完成对值的排序。

> 冒泡排序算法的一般策略如下:扫描该列表且比较邻接元素，如果它们不是按相对顺序排列则将其互换。这就像把最大值“冒泡”到列表的最后位置，这是它在最终已排序列表中的恰当位置。然后再次扫描该列表，冒泡出倒数第二个值。继续这一过程，直至所有元素都被冒泡到它们正确的位置。
每经过一轮，该冒泡排序算法都会将最大值移至其最终位置。每一轮同样也可能会重新配置其他元素的位置。比如，如果开始时列表为:
9	6	8	12	3	1	7
我们将首先比较9和6，发现它们的顺序不正确，则将它们互换，得到：
6	9	8	12	3	1	7
以此类推，得到	6	8	9	3	1	7	12，第一轮排序完成
如果n个元素则需要n-1轮

实现

```java
/**
 * 冒泡排序
 */
public static <T extends Comparable<? super T>> void bubbleSort(T[] data) {
    int position;
    int scan;
    for (position = data.length - 1; position >= 0; position--) {
        for (scan = 0; scan <= position - 1; scan++) {
            if (data[scan].compareTo(data[scan + 1]) > 0) {
                swap(data, scan, scan + 1);
            }
        }
    }
}
```

上面三种都是低效排序，相对来说比较简单，使用嵌套循环。

#### 快速排序

快速排序（quick sort〉算法是这样对列表进行排序的:通过使用一个任意选定的分区元素( partition element）将该列表分区，然后对分区元素的任一边的子列表进行递归排序。

> 快速排序算法的一般策略如下：**首先，选择一个列表元素作为分区元素。下一步，分割该列表，使得小于该分区元素的所有元素位于该元素的左边，所有大于该分区元素的元素位于右边。最后，将该快速排序策略（递归式）应用于两个分区。**

代码实现

```java
/**
 * -----------快速排序-----------
 */
public static <T extends Comparable<? super T>> void quickSort(T[] data) {
    quickSort(data, 0, data.length - 1);
}

private static <T extends Comparable<? super T>> void quickSort(T[] data, int min, int max) {
    // 递归的基本情形是：一个含有一个或更少元素的列表，他是已排序了的。也就是if
    if (min < max) {
        // create partitions，分区
        int indexOfPartition = partition(data, min, max);

        // sort the left partition (lower values)
        quickSort(data, min, indexOfPartition - 1);

        // sort the right partition (higher values)
        quickSort(data, indexOfPartition + 1, max);
    }
}

/**
 * 返回分区元素索引值
 */
private static <T extends Comparable<? super T>> int partition(T[] data, int min, int max) {
    T partitionElement;
    int left;
    int right;
    int middle = (min + max) / 2;
    // 使用中间元素作为分区
    partitionElement = data[middle];
    // 暂时把它移开 中间和0交换
    swap(data, middle, min);

    left = min;
    right = max;

    while (left < right) {
        // 查找元素，大于分区元素
        while (left < right && data[left].compareTo(partitionElement) <= 0) {
            left++;
        }
        // 小于分区元素
        while (data[right].compareTo(partitionElement) > 0) {
            right--;
        }
        // 交换元素
        if (left < right) {
            swap(data, left, right);
        }
    }
    // 移动分区元素
    swap(data, min, right);
    return right;
}
```

#### 归并排序

归并排序法是另一种递归排序算法，通过将列表递归式分成两半直至每一子列表都只含有一个元素，然后将这些子列表按顺序重组，这样就完成了对列表的排序。(先拆后组)

> 归并排序算法的一般策略如下:首先将该列表分成两个大约相等的部分，然后对每一部分列表递归调用其自身。继续该列表的递归分解，直至达到该递归的基本情形，这时该列表被分割成长度为Ⅰ的列表，根据定义，它是已排序的了。然后，随着程序控制权传回至该递归调用结构，该算法将两个递归调用所产生的那两个排序子列表归并为一个排序列表。

代码实现

```java
/**
     * ---------归并排序-------
     */
    private static <T extends Comparable<T>> void mergeSort(T[] data) {
        mergeSort(data, 0, data.length - 1);
    }

    private static <T extends Comparable<T>> void mergeSort(T[] data, int min, int max) {
        if (min < max) {
            int mid = (min + max) / 2;
            mergeSort(data, min, mid);
            mergeSort(data, mid + 1, max);
            merge(data, min, mid, max);
        }
    }

    private static <T extends Comparable<T>> void merge(T[] data, int first, int mid, int last) {
        T[] temp = (T[])(new Comparable[data.length]);

        // 子数组的第 一个节点
        int first1 = first;
        int last1 = mid;
        // 子数组的第 二个节点
        int first2 = mid + 1;
        int last2 = last;
        // 下个下标在临时数组中打开
        int index = first1;
        // 复制最小的项从每个子数组到临时数组，直到子数组只剩一个
        while (first1 <= last1 && first2 <= last2) {
            if (data[first1].compareTo(data[first2]) < 0) {
                temp[index] = data[first1];
                first1++;
            }else {
                temp[index] = data[first2];
                first2++;
            }
            index++;
        }
        //复制其余元素从第1个子数组，如果有的话
        while (first1 <= last1) {
            temp[index] = data[first1];
            first1++;
            index++;
        }
        //复制其余元素从第二个子数组，如果有的话
        while (first2 <= last2) {
            temp[index] = data[first2];
            first2++;
            index++;
        }
        // 复制合并的数据到原始数组
        for (index = first; index <= last; index++) {
            data[index] = temp[index];
        }
    }
```

#### 基数排序

基数排序是基于队列处理的

> 排序要基于某个特定的值，这个值称为排序关键字(sort key)。例如，一组人可以基于他们的姓氏进行排序。基数排序并不是基于排序关键字来比较排序项，而是基于排序关键字的结构。对于排序关键字中每个数字/字符的每种可能取值,都会创建一个单独的队列。队列的数目(或可能取值的种数〉就称为基数（radix)。例如，如果要排序全部由小写字母构成的字符串，则基数就是26。我们会用到26个单独的队列，每个队列表示可能的字符。如果要排序十进制数，则基数应该是10，0~9的每个数字都对应着一个队列。

代码实现(书)，只写了4位数

```java
public static <T extends Comparable<T>> void radixSort(Integer[] list, int maxDigit) {
    String temp;
    Integer numObj;
    int digit;
    int num;
    Queue<Integer>[] digitQueues = (LinkedList<Integer>[]) (new LinkedList[10]);
    for (int digitVal = 0; digitVal <= 9; digitVal++) {
        digitQueues[digitVal] = new LinkedList<>();
    }
    // 排序列表
    for (int position = 0; position <= maxDigit - 1; position++) {
        for (int scan = 0; scan < list.length; scan++) {
            temp = String.valueOf(list[scan]);
            if (temp.length() <= maxDigit - 1 - position) {
                continue;
            }
            // 1:个位数
            digit = Character.digit(temp.charAt(maxDigit - 1 - position), 10);
            digitQueues[digit].add(list[scan]);
        }

        // 收集成员回到列表中
        num = 0;
        for (int digitVal = 0; digitVal <= 9; digitVal++) {
            while (!(digitQueues[digitVal].isEmpty())) {
                numObj = digitQueues[digitVal].remove();
                list[num] = numObj;
                num++;
            }
        }
    }
}
```

其他写法

```java
private static void radixSort(int[] arr) {
    //待排序列最大值
    int max = arr[0];
    int exp;//指数

    //计算最大值
    for (int anArr : arr) {
        if (anArr > max) {
            max = anArr;
        }
    }

    //从个位开始，对数组进行排序
    for (exp = 1; max / exp > 0; exp *= 10) {
        //存储待排元素的临时数组
        int[] temp = new int[arr.length];
        //分桶个数
        int[] buckets = new int[10];

        //将数据出现的次数存储在buckets中
        for (int value : arr) {
            //(value / exp) % 10 :value的最底位(个位)
            buckets[(value / exp) % 10]++;
        }

        //更改buckets[i]，
        for (int i = 1; i < 10; i++) {
            buckets[i] += buckets[i - 1];
        }

        //将数据存储到临时数组temp中
        for (int i = arr.length - 1; i >= 0; i--) {
            temp[buckets[(arr[i] / exp) % 10] - 1] = arr[i];
            buckets[(arr[i] / exp) % 10]--;
        }

        //将有序元素temp赋给arr
        System.arraycopy(temp, 0, arr, 0, arr.length);
    }
}
```

遍历数据的轮次是一个常量，它与排序关键字中的字符数目有关，我们称之为c。那么，该排序算法的时间复杂度是 c*n。记住，从第﹖章的讨论中可知，在计算算法的时间复杂度时，忽略了常量。于是，基数排序算法的复杂度为O(n)。那么为什么不是所有的排序都使用基数排序法呢?首先，每个基数排序算法都是为给定问题的排序关键字特别设计的。其次，如果排序关键字中的数字数目(c）与列表中的元素数目(n）非常接近，那么该基数排序算法的实际时间复杂度接近n'，而不是 n。另外，我们还有记住，还有另一个常量会影响空间复杂度，那就是基数，即排序关键字中每个位置或字符的可能值数目。例如，假设要实现一个基数排序,其排序关键字是Unicode字符集的所有字符。由于这个字符集有不止100 000个字符，那么我们就需要这么多的队列了。

小问题

什么时候线性查找会优于对数查找?

> 在相对较小的未排序列表以及在不支持递归的语言中，线性查找更好些。

哪种查找方法要求列表是已排序的?

> 二分查找法。

什么时候顺序排序会优于递归排序?

> 在相对较小的数据集以及在不支持递归的语言中，顺序排序更好些。

插入排序算法使用了什么技术进行排序?

> 插入排序算法通过反复地将某一特定值插入到该列表某个已排序的子集中，来完成对列表值的排序。

冒泡排序算法使用了什么技术进行排序?

> 冒泡排序算法通过反复地比较列表中的相邻元素且在它们未按顺序排列时将其位置互换，从而完成对列表的排序。

选择排序算法使用了什么技术进行排序?

> 选择排序算法通过反复地将某一特定值放到它在列表中的最终排序位置从而完成对某一列值的排序，它是一种复杂度为O(n)的排序算法。

快速排序算法使用了什么技术进行排序?

> 快速排序算法是这样对列表进行排序的:通过使用一个任意选定的分区元素将该列表分区，然后对分区元素的任一边子列表进行递归排序。

归并排序算法使用了什么技术进行排序?

> 归并排序算法，通过将列表递归式分成两半直至每一子列表都含有一个元素，然后将这些子列表按顺序重组，这样就完成了对列表的排序。

使用基数排序法对全为小写的人名进行排序时，需要多少个队列?

> 需要27个队列，字母表的26个字母需要26个队列，还有一个队列用来在排序前、排序中和排序后存储该列表。

### 10 树

之前的集合（栈、队列、列表）都是线性数据结构，他们的元素是按照一个接一个顺序排列的。

**树是一种非线性结构，其中的元素被组织成一个层次的结构**

> 位于树中较低层的结点是上一层结点的**子结点**。同一父节点的两个/多个结点叫**兄弟结点**。**根节点**没有父结点，**叶子结点**没有子结点。

树有多种分类方式。最重要的一条标准是树中任一结点可以具有的最大孩子数目。这个值有时候也称为该树的**度**（ order)。**对结点所含有的孩子数目无限制的树称为广义树( general tree)。我们将每一结点限制为不超过n个孩子的树称为一棵n元树〈n-ary tree)。**

**结点最多具有两个孩子的树称为二叉树(binary tree)。**

对树进行分类的另一种方式是该树平衡与否。根据所使用的算法，对平衡的定义有多种。**粗略地说，如果树的所有叶子都位于同一层或者至少是彼此相差不超过一个层，就称之为是平衡的**。含有m个元素的平衡n元树具有的高度为lognm。因此，一棵含n个结点的平衡二叉树具有的高度为log2n。

**完全树**( complete tree）的概念与树的平衡是相关的。如果某树是平衡的，且底层所有叶子都位于树的左边，则认为该树是完全的。虽然这看上去是一个武断的概念，但是该定义暗示了树如何存储在特定实现中。定义该概念的另一种方式是，完全二叉树在每个k层上都具有2个结点，最后一层除外，在最后一层中的结点必须是最左边结点。

另一个相关概念是**满树**(full tree)。如果一棵n元树的所有叶子都位于同一层且每-结点要么是一片叶子要么正好具有n个孩子，则称此树是满的。

```java
如一个3元树，1-222（完全满树），1-222-3*333（完全满树）
1-222-333（最左结点为满，则只能说是完全树）
1-222-3（最左结点有结点，完全树）
```

#### 树的实现策略

#### 计算策略

特别是二叉树而言，一种策略是使用数组来存储一棵树。一种可能的策略如下：**对于任何存储在数组位置n处的元素而言，该元素的左孩子将存储在位置(2×n+1)处，该元素的右孩子则存储在位置(2×(n十1))处**。但是，如果我们存储的树不是完全的或只是相对完全的（不平衡会浪费很大空间），则该数组会为不包含数据的树位置分配空间。

#### 链接策略

链接策略模拟了操作系统管理内存的方式。它按照先来先服务的基准连续分配数组位置，而不是通过其在树中的定位将树元素指派到数组位置上。**该数组的每一元素都是一个结点类**，它与我们前面讨论的TreeNode类相似。但是，**每一结点存储的将是每一孩子（可能还有其双亲）的数组索引**，而不是作为指向其孩子（可能还有其双亲）指针的对象引用变量。这种方式使得元素能够连续存储在数组中，因此不会浪费空间。**但是，该方式增加了删除树中元素的成本，因为它要么需要对剩余元素进行移位以维持连续状态**，要么需要保留一个空闲列表。该数组中元素的顺序仅仅由它们进入该树的顺序决定。在本例中，进入顺序假定为A、C、B、E、D、F。

```java
如有树：A-BC-DE-F, A-B,A-C,B-D,B-E,D-F
数组：| A | C | B | E | D | F |
     |2|1|   |4|3|   | 5 |   |
```

设计要点：对于元素数量很少时，线性结构成本比较小，树成本大，当元素数量增大时反之。

#### 树的遍历

有一颗树：A-B，A-C，B-D，B-E，D-F

**前序遍历**( preorder traversal)，从根结点开始，访问每一结点及其孩子。（ABDFEC）

**中序遍历**（ inorder traversal)，从根结点开始，访问结点的左孩子，然后是该结点,再然后是任何剩余结点。（FDBEAC）【从最左的子的子的子...开始**访问**，子没有其他，然后访问该结点的父结点，试着遍历父结点的其他子，遍历完访问当前父结点B的父结点A，遍历A结点，访问C）

**后序遍历**（ postorder traversal)，从根结点开始，访问结点的孩子，然后是该结点。（FDEBCA）

【从根开始遍历左子结点，然后访问该结点，然后访问该结点的父节点的**右子结点**（或者说兄弟结点），在访问父节点B，再访问B的兄弟C，最后A】

**层序遍历**（level-order traversal)，从根结点开始，访问每一层的所有结点，一次一层。（ABCDE）

对于带有id和pid类型的Json数组转成树形结构

```JavaScript
toTree () {
      let content = this.districts;
      var newlist = [];
      // 提前创建数组的新属性 
      for (var i = 0; i < content.length; i++) {
        content[i].children = [];
      }
      for (var j = 0; j < content.length; j++) {
        // 找出顶点
        if (content[j].pid === 0) {
            newlist = content.splice(j, 1);
        }
      }
      // 深度遍历
      this.deepSort(newlist, content);
      this.treeData = newlist;
      console.log(this.treeData);
    },
    deepSort (list, content) {
      var content1 = [];
      // 当前数组遍历
      for (var m = 0; m < list.length; m++) {
        // 全数组遍历
        for (var n = 0; n < content.length; n++) {
          if (list[m].id === content[n].pid) {
            // 找到当前的子，将它放入children中（不能在这里依据判断来创建children，因为数组的结构要求一致？）
            list[m].children.push(content[n]);
          } else {
            // 不是当前的子的结点就放入另一个数组，剩余处理
            content1.push(content[n])
          }
        }
      }
      // 循环当前层级，将它的子执行dfs，这时候全部数组为剩余数组
      for (var o = 0; o < list.length; o++) {
        this.deepSort(list[o].children, content1)
      }
    },
```

#### 二叉树

二叉树的可能操作如下。

|操作|说明|
|-|-|
|getRoot|返回指向二叉树根的引用|
|isEmpty|判定该树是否为空|
|size|判定树中的元素数目|
|contains|判定指定目标是否在该树中|
|find|如果找到指定元素，则返回指向其的引用|
|toString|返回树的字符串表示|
|iteratorInOrder|为树的中序遍历返回一个迭代器|
|iteratorPreOrder|为树的前序遍历返回一个迭代器|
|iteratorPostOrder|为树的后序遍历返回一个迭代器|
|iteratorLevelOrder|为树的层序遍历返回一个迭代器|


往树中插入和删除的操作是不符合树模型概念的，就像添加/删除栈和队列，只能操作顶部，或者两端，而不能操作中间。（如果删除树中元素，子结点，父结点该如何变化？）

树接口代码，由于少代码，并未完成。

```java

```

决策树(decision tree）是这样一种树，其结点表示决策点，其子结点表示在该决策点的可选项。决策树的叶结点表示可能的推断，这些推断是基于答案而得出的。（就像流程图一样，或者说是天赋树，就诊流程）

### 11 二叉查找树

二叉查找树(binary search tree)是一种带有附加属性的二叉树，即对树中的每个结点，其左孩子都要小于其父结点，而父结点又小于或等于其右孩子。

|操作|说明|
|-|-|
|addElement|往树中添加一个元素|
|removeElement|从树中删除一个元素|
|removeAllOccurrences|从树中删除所指定元素的任何存在|
|removeMin|删除树中最小元素|
|removeMax|删除树中最大元素|
|findMin|返回一个指向树中最小元素的引用|
|findMax|返回一个指向树中最大元素的引用|


从二叉查找树中删除一个元素时,必须推选出另一个结点来代替要被删除的那个结点。

#### 平衡二叉查找树

右旋（一般情况左侧长）

左旋（一般情况右边长）

右左旋

左右旋

#### AVL树

> 右子树的高度减去左子树的高度称为该结点的平衡因子，如果平衡因子大于1或小于-1则需要重新平衡

树（或树的任何子树）只有两种途径能变得不平衡：插入结点或删除结点。因此，在每次进行这两种操作时，都必须更新平衡因子，然后从插入/删除结点的那个地方开始检查树的平衡性，接着上溯一直检查到树的根结点。由于需要上溯树，因此AVL树通常最好实现为每个结点都包含一个指向其父结点的引用。

同样AVL树也有四种旋转

#### 红黑树

每个结点存储一种颜色（黑/红）

- 根节点为黑色
- 红色结点的所有孩子都为黑色
- 从树根到树叶的每条路径都包含同样数目的黑色结点

插入元素时开始总把新元素的颜色设置为红色，然后平衡树。

删除元素时也一样

### 12 优先队列、堆

**堆**(heap）就是具有两个附加属性的一棵二叉树：（类似金字塔，上面最小，下面最大）

- 它是一棵完全树，在第10章我们对其进行了描述。
- 对每一结点，它小于或等于其左孩子和右孩子。

可以定义为最小堆（根最小），或者最大堆（根最大）。

|操作|说明|
|-|-|
|addElement|将给定元素添加到堆中|
|removeMin|删除堆的最小元素|
|findMin|返回一个指向堆中最小元素的引用|


addElement

因为一个堆就是一棵完全树,所以对于插入的新结点而言，只存在一个正确的位置，且它要么是h层左边的下一个空位置,要么是h+1层左边的第1个位置(如果h层是满的话）

**优先级队列**

优先级队列( priority queue）就是遵循两个排序规则的集合。首先，具有更高优先级的项目在先。第二，具有相同优先级的项目使用先进先出方法来确定其排序。优先级队列具有多种应用（比如，操作系统中的任务调度，网络中的通信调度，甚至是汽车维修处的作业调度)。

#### 堆排序

heapSort方法的两部分构成：添加列表的每个元素，然后一次删除一个元素。

> 对某个数字列表进行排序。这个过程相当简单，只需将列表的每一元素添加到堆中，然后一次一个地将它们从根中删除。在最小堆的情形下，排序结果将是该列表以升序排列。在最大堆的情形下，排序结果将是该列表以降序排列。由于添加和删除操作的复杂度都为O(log n),因此可以得出堆排序的复杂度也是O(log n)。但是,这些操作的复杂度为O(log n)，指的是在含有n个元素的列表中添加和删除一个元素。对任一给定的结点，插入到堆的复杂度都是O(log n)，因此n个结点的复杂度将是O(n log n)。删除一个结点的复杂度为O(logn)，因此对n个结点的复杂度为O(n log n)。对于堆的排序算法，我们需要执行addElement和removeElement两个操作n次，即列表中每个元素一次。因此，最终的复杂度为2×n×log n，即 O(n log n)。

堆排序的复杂度为O(nlogn)

1. 构建初始堆，将待排序列构成一个大顶堆(或者小顶堆)，升序大顶堆，降序小顶堆；
2. 将堆顶元素与堆尾元素交换，并断开(从待排序列中移除)堆尾元素。
3. 重新构建堆。
4. 重复2~3，直到待排序列中只剩下一个元素(堆顶元素)。

数组实现堆比链表更简洁。

代码实现

```java
/**
 * -------堆排序-------小顶堆
 */
public static void heapSort(Integer[] arr) {
    //1.构建大顶堆
    for (int i = arr.length / 2 - 1; i >= 0; i--) {
        //从第一个非叶子结点从下至上，从右至左调整结构
        adjustHeap(arr, i, arr.length);
    }
    //2.调整堆结构+交换堆顶元素与末尾元素
    for (int j = arr.length - 1; j > 0; j--) {
        swap(arr, 0, j);//将堆顶元素与末尾元素进行交换
        adjustHeap(arr, 0, j);//重新对堆进行调整
    }
}

public static void adjustHeap(Integer[] arr, int i, int length) {
    int temp = arr[i];//先取出当前元素i
    for (int k = i * 2 + 1; k < length; k = k * 2 + 1) {//从i结点的左子结点开始，也就是2i+1处开始
        if (k + 1 < length && arr[k] < arr[k + 1]) {//如果左子结点小于右子结点，k指向右子结点
            k++;
        }
        if (arr[k] > temp) {//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）
            arr[i] = arr[k];
            i = k;
        } else {
            break;
        }
    }
    arr[i] = temp;//将temp值放到最终的位置
}

private static <T extends Comparable<? super T>> void swap(T[] data, int index1, int index2) {
        T temp = data[index1];
        data[index1] = data[index2];
        data[index2] = temp;
    }
```

### 13 Set与Map集合

Set集合是对象的唯一集合，通常用于确定某个元素是否是集合的成员。

Set主要方法：（还有remove，removeAll，add，toArray等）

|boolean|contains(Object o)，如果Set集合中含有指定元素返回true|
|-|-|
|boolean|containsAll(Collection<? extends> c)如果Set集合中含有指定集合所有元素|
|boolean|retainAll(Collection<? extends> c)在Set集合中保留指定集合包含的所有元素|


Map是对象的一个集合，可以使用唯一关键字来进行检索。

Map主要方法：（）

|Set<Map.Entry<K,V>>|entrySet()返回一个含有Map映射的Set集合|
|-|-|
|boolean|containsKey(Object key)Map集合中含有指定关键字|
|boolean|containsValue(Object value)Map集合中含有指定的值|
|V|remove(Object key)从Map集合中删除某映射|
|Collection|values()返回一个Collection集合，该集合含有Map集合中的值|


使用Set集合场景：域阻塞器

使用Map场景：用户id和用户信息

> **javaApi不是把树看作集合，而是实现其他集合的一种方式**
TreeSet和TreeMap用的是红黑平衡二叉查找树（在添加删除元素时仍然保持平衡，所有操作复杂度都为O(log n)
TreeSet是基于TreeMap类构建的，同理HashSet也是基于HashMap

HashMap和HashSet类是使用散列（哈希）实现的，元素在散列表中的位置是由散列函数确定的。

散列（哈希）表的每个位置称为一个单元cell或桶bucket

对每个元素计算哈希值来确定位置，两个元素映射到同一位置情况称为冲突。

默认初始大小16，扩容因子0.75....

### 14 多路查找树

多路查找树中每一结点的孩子树可以多于两个，且每一结点处可以存储多个元素。

2-3树

2-3树中的结点包含1个或2个元素，且具有0个、2个或3个孩子。（挺诡异的，同样是左小右大）

2-4树

2-4树对2-3树进行扩展，包括了4结点的使用。

**B树**

B树是一大类型的多路查找树，2-3树和2-4树这种结点的最大孩子数目称为B树的阶（order）。因此2-3树是3阶B树。

m阶B树具有如下树形

- 如果根节点不是叶节点，则其至少有两棵子树
- 每一非根内部结点n都有k-1个元素和k个孩子，其中[m/2] <= k <= m
- 每一叶子n都有k -1个元素，其中[m/2] <= k <= m
- 所有叶子都位于同一层。

### 15 图

**无向图**

每个结点叫**顶点（vertice）**，结点之间的连接是**边（edge）**

无向图的边无序。因此无向图中边记为（A,B）或（B,A）

两点之间有一条边，则称两点相邻的。

连通一个顶点及其自身的边称为自循环/环。如（A，A）

拥有最大数目的连接边，则认为这个无向图是**完全的**，如有n个顶点的完全无向图，有n(n-1)/2条边

**路径**：是图的一系列边。（无向图中路径是双向的），路径的长度就是边数。

如果无向图中的任意两个顶点之间都存在一条路径，则认为这个无向图是连通的。

**环路**：一种首顶点和末顶点相同且没有重边的路径。（三角型）

**有向图**

有向图的边不能倒着写。另外连通情况也不同，必须从一个顶点**指回**这个顶点。

（树也是一种特殊的图）

**网络**（也叫**加权图**）

每条边都带权重（代价）的图。比如交通价格网络，可以用于确定最便宜的路线。

根据需要可以是有向，无向。边表示：（A，B，权重）

**常用的图算法**

如遍历，寻找最短路径等。

#### 图的遍历

广度优先遍历（breadth-first traversal）和深度有限遍历（depth-first traversal）

由于图中不存在根结点，因此图的遍历可以从其中的任一顶点开始。
可以用一个队列和一个无序列表来构造图的**广度**优先遍历。我们将使用**队列**( traversalQueue）来管理遍历，使用**无序列表**(resultList〉来构造出结果。第一步，起始顶点进入队列traversalQueue，同时标记该顶点为已访问的(visited)。然后开始循环，该循环一直持续到travesalQueue为空时停止。在这个循环中，从traveralQueue中取出这个首顶点,并将它添加到resultList 的末端。接着，让所有与当前顶点邻接且尚未被标记为visited 的各个顶点依次进入队列traversalQueue，同时把它们逐个标记为visited;然后再重复上述循环。对每个己访问的顶点都重复这一过程，直到traversalQueue为空时结束，这时意味着无法再找到任何新的顶点。

**深度优先遍历使用的是栈来管理遍历**

代码大致示例，无法运行

```java
public class GraphTest<T> {
    int numVertices = 10;
    T[] vertices = null;
    int[][] adjMatrix = new int[10][10];

    public Iterator<T> iteratorDFS(int startIndex) {
        // 顶点
        Integer x;
        boolean found;
        Stack<Integer> traversalStack = new Stack<>();
        List<T> resultList = new ArrayList<>();
        boolean[] visited = new boolean[numVertices];

        if (!indexIsValid(startIndex)) {
            return resultList.iterator();
        }

        traversalStack.push(startIndex);
        resultList.add(vertices[startIndex]);
        visited[startIndex] = true;

        while (!traversalStack.isEmpty()) {
            x = traversalStack.peek();
            found = false;

            // 找到一个顶点临近x，且没被访问过的 然后放入栈中 adjacent：邻近的
            for (int i = 0; i < numVertices; i++){
                if (adjMatrix[x][i] != 0 && !visited[i]) {
                    traversalStack.push((i));
                    resultList.add(vertices[i]);
                    visited[i] = true;
                }
            }
            if (!traversalStack.isEmpty()) {
                traversalStack.pop();
            }
        }
        // return new GraphIterator(resultList.iterator());
        return new ObjectGraphIterator(resultList.iterator());
    }
    // 未实现的方法
    public boolean indexIsValid(int startIndex) {
        return false;
    }
}
```

**广度优先遍历步骤**

(1)往 traversalQueue中添加9，并且把它标记为visited。
(2）从 traversalQueue中取出9。
(3）往resultList中添加9。
(4）往traversalQueue中添加6、7和8，同时把它们逐一标记为visited。
(5)从traversalQueue 中取出6。
(6）往resultList中添加6。
(7)往traversalQueue 中添加3、4，同时把这两个顶点标记为visited。(8）从traversalQueue中取出7，并将它添加到resultList 中。
(9）往traversalQueue中添加5，并且把它标记为visited。
(10)从traversalQueue中取出8，并将它添加到resultList中（这时不再往traversal-Queue中添加任何新的顶点，因为顶点8再也没有尚未访问过的邻居了)。
( 11)从traversalQueue中取出3，并将它添加到resultList 中。
( 12）往traversalQueue 中添加1，并且把它标记为visited。
( 13）从traversalQueue 中取出4，并将它添加到resultList 中。
(14）往traversalQueue中添加2，并且把它标记为visited。
(15）从traversalQueue中取出5，并将它添加到resultList中（由于再也没有未访问过的邻居，因此不需再往traversalQueue中添加顶点)。
(16）从traversalQueue 中取出l，并将它添加到resultList中（由于再也没有未访问过的邻居，因此不需再往 traversalQueue 中添加顶点)。
( 17)从traversalQueue 中取出2，并将它添加到resultList 中。

resultList顺序为 [9、6、7、8、3、4、5、1、2]

**两种算法都可以表述成递归形式**

```java
// 伪代码
dfs(node x) {
    // 将当前结点标记为已访问
    visit(x);
    // 将当前结点添加到结果列表的尾部
    resultlist.addToRear(x);
    // 遍历x的相邻结点 
    foreach node y adjacent to x {
        // 如果相邻节点y没有被访问过，则dfs此结点y
        if y not visited {
            dfs(y);
        }
    }
}
```

**测试连通性**：任意两个顶点之间都存在一条路径，则认为图是连通的。（每个点都有人连）

在一个含n个顶点的图中，当且仅当对每个顶点v，从v开始的BFS的resultList大小都是n，则该图就是连通的。

生成树：是一颗含有图所有顶点和部分边（不可能是所有边）的树。如图。

**最小生成树**：其边的权重综合小于或等于同一个图中其他任何一棵生成树的权重总和

**步骤**：加权图的每条边会用一个三元组来表示;这个三元组中包括起始顶点、终止顶点和权重。然后，我们再任意选取一个起始顶点（不管是哪一个)，并将它添加到最小生成树中。然后，将所有含起始顶点的边按照权重次序添加到minheap(最小堆）中。记住，如果处理的是有向网络，则只会添加那些以这个特定顶点为起点的边。
接着从minheap 中取出最小边，并将这条边和那个新顶点添加到最小生成树中。下-步，我们往minheap中添加所有含该新顶点且另一顶点尚不在最小生成树中的边。继续这一过程，直到最小生成树含有原始图中的所有顶点(或minheap为空）时结束。

代码略

**判定最短路径**：

要将广度优先遍历算法转变成寻找最短路径的算法，只需在遍历期间再对每个顶点存储另两个信息即可:从起始顶点到本顶点的路径长度，以及路径中作为本顶点前驱的那个顶点。接着要修改循环，使得当抵达目标顶点时循环将终止。最短路径的路径长度就是从起始顶点到目标顶点前驱的路径长度再加1;如果要输出这条最短路径上的顶点，只需沿着前驱链回溯即可。

#### 图的实现策略

需要实现：添加顶点、删除顶点、添加边、删除边、从特定的顶点开始遍历（BFS/DFS）。可以实现成iterator，还可以实现判定（两点之间）最短路径、判定两顶点之间是否为相邻、构造最小生成树、测试连通性操作。

不管顶点使用的存储机制是什么，都必须能让我们在遍历（和其他算法）期间将顶点标记为已访问的（(visited)。这只需往表示顶点的那个类添加一个布尔变量即可完成。

**邻接矩阵**：使用二维布尔数组来表示图。无向图

有向图，如果有权重的话，在每个单元格中再加一个权重的属性，没有的设置为null

**邻接矩阵实现无向图**

代码实现，并未实现，只是设计

```java
package com.miaski.study.datastructure.graph;

import java.util.Iterator;

/**
 * @author bfq
 */
public interface GraphADT<T> {

    /**
     * 添加顶点到图
     * @param vertex 要被添加到图中的点
     */
    void addVertex(T vertex);

    /**
     * 从图中移除顶点
     * @param vertex 顶点
     */
    void removeVertex(T vertex);

    /**
     * 插入一条边在两点之间
     * @param vertex1 点1
     * @param vertex2 点2
     */
    void addEdge(T vertex1, T vertex2);

    /**
     * 移除一条边在两点之间
     * @param vertex1 点1
     * @param vertex2 点2
     */
    void removeEdge(T vertex1, T vertex2);

    /**
     * 返回一个广度优先遍历器，从给定的点开始
     * @param startVertex 起点
     * @return 广度遍历器
     */
    Iterator iteratorBFS(T startVertex);

    /**
     * 返回一个深度优先遍历器，从给定的点开始
     * @param startVertex 起点
     * @return 深度遍历器
     */
    Iterator iteratorDFS(T startVertex);

    /**
     * 返回一个包含两点之间最短路径的迭代器
     * @param startVertex 起点
     * @param targetVertex 终点
     * @return 最短路径迭代器
     */
    Iterator iteratorShortestPath(T startVertex, T targetVertex);

    /**
     * 图是否为空
     * @return 图是否为空
     */
    boolean isEmpty();

    /**
     * 判断图是否是连通的
     * @return 是否连通
     */
    boolean isConnected();

    /**
     * 返回图的顶点数
     * @return 顶点数
     */
    int size();

//    String toString();
}

package com.miaski.study.datastructure.graph;

import com.miaski.study.datastructure.collection.LinkedQueue;
import com.miaski.study.datastructure.collection.QueueADT;
import org.apache.commons.collections.iterators.ObjectGraphIterator;

import java.util.*;

/**
 * @author bfq
 */
public class GraphTest<T> {
    int numVertices = 10;
    T[] vertices = null;
    int[][] adjMatrix = new int[10][10];

    public Iterator<T> iteratorDFS(int startIndex) {
        // 顶点
        Integer x;
        boolean found;
        Stack<Integer> traversalStack = new Stack<>();
        List<T> resultList = new ArrayList<>();
        boolean[] visited = new boolean[numVertices];

        if (!indexIsValid(startIndex)) {
            return resultList.iterator();
        }

        traversalStack.push(startIndex);
        resultList.add(vertices[startIndex]);
        visited[startIndex] = true;

        while (!traversalStack.isEmpty()) {
            x = traversalStack.peek();
            found = false;

            // 找到一个顶点临近x，且没被访问过的 然后放入栈中 adjacent：邻近的
            for (int i = 0; i < numVertices; i++){
                if (adjMatrix[x][i] != 0 && !visited[i]) {
                    traversalStack.push((i));
                    resultList.add(vertices[i]);
                    visited[i] = true;
                }
            }
            if (!traversalStack.isEmpty()) {
                traversalStack.pop();
            }
        }
        // return new GraphIterator(resultList.iterator());
        return new ObjectGraphIterator(resultList.iterator());
    }
    // 未实现的方法
    public boolean indexIsValid(int startIndex) {
        return false;
    }
}

package com.miaski.study.datastructure.graph;

import java.util.Iterator;

/**
 * 使用boolean数组来实现图
 * @author bfq
 */
public class Graph<T> implements GraphADT<T> {

    protected final int DEFAULT_CAPACITY = 5;
    protected int numVertices;
    protected boolean[][] adjMatrix;
    protected T[] vertices;
    protected int modCount;

    public Graph() {
        numVertices = 0;
        this.adjMatrix = new boolean[DEFAULT_CAPACITY][DEFAULT_CAPACITY];
        this.vertices = (T[])(new Object[DEFAULT_CAPACITY]);
    }

    @Override
    public void addVertex(T vertex) {
        if ((numVertices + 1) == adjMatrix.length) {
            expandCapacity();
        }
        vertices[numVertices] = vertex;
        for (int i = 0; i < numVertices; i++)   {
            adjMatrix[numVertices][i] = false;
            adjMatrix[i][numVertices] = false;
        }
        numVertices++;
        modCount++;
    }

    /**
     * 图的邻接矩阵实现中的expandCapacity 比其他数组实现中的类似方法更有趣。
     * 它不再只是简单的扩展一个数组并复制内容了。
     * 记住，对于图，我们不仅必须扩展顶点数组并把已有顶点复制到新数组中，
     * 而且还必须扩展邻接列表的容量并把旧内容复制到这个新列表中。
     */
    protected void expandCapacity() {
        T[] largerVertices = (T[])(new Object[vertices.length * 2]);
        boolean[][] largerAdjMatrix = new boolean[vertices.length * 2][vertices.length * 2];
        for (int i = 0; i < numVertices; i++) {
            // 原来是这么写，优化后用System类
            // for (int j = 0; j < numVertices; j++) {
            //                largerAdjMatrix[i][j] = adjMatrix[i][j];
            //            }
            System.arraycopy(adjMatrix[i], 0, largerAdjMatrix[i], 0, numVertices);
            largerVertices[i] = vertices[i];
        }
        vertices = largerVertices;
        adjMatrix = largerAdjMatrix;
    }

    @Override
    public void removeVertex(T vertex) {

    }

    @Override
    public void addEdge(T vertex1, T vertex2) {
//        addEdge(getIndex(vertex1), getIndex(vertex2));
    }

    public void addEdge(int index1, int index2) {
//        if (indexIsValid(index1) && indexIsValid(index2)) {
//            adjMatrix[index1][index2] = true;
//            adjMatrix[index2][index1] = true;
//            modCount++;
//        }
    }

    @Override
    public void removeEdge(T vertex1, T vertex2) {

    }

    @Override
    public Iterator iteratorBFS(T startVertex) {
        return null;
    }

    @Override
    public Iterator iteratorDFS(T startVertex) {
        return null;
    }

    @Override
    public Iterator iteratorShortestPath(T startVertex, T targetVertex) {
        return null;
    }

    @Override
    public boolean isEmpty() {
        return false;
    }

    @Override
    public boolean isConnected() {
        return false;
    }

    @Override
    public int size() {
        return 0;
    }
}
```

### UML

统一建模语言（Unified Modeling Language）

从上到下分别是【类名】【属性/成员变量】【方法/操作】

其中属性和方法可以使用 +public、#protected、-private来表示可见性。

如： - title :String （private String title）

如： +checkout(title :String, number :int) : boolean { }

**继承关系使用空心箭头表示**

**关联性关系**

关联性用两个类之间的一条实线表示，且可以在任何一边用该关系的基数( cardinality)加以注解。例如，图A.3显示了LibraryCustomer和 LibraryItem之间关联性。基数0..*表示“0或多个”，它表示任何给定的图书馆用户可以借出0件或多件物品，而任何给定的物品可以被多个用户借出。一个关联性的基数还可以说明其他关系，比如，某个确定的数或某个特定的范围。例如，如果允许某个用户最多可以借出5件物品，则基数可以指定为0..5。

**聚集关系**：一个类的部分是由其他类构成

**实现关系**

**使用关系**：

### 正确面向对象

示例硬币类

```java
package com.miaski.study.datastructure;

import org.junit.Test;

/**
 * @author bfq
 */
public class Coin {

    private final int HEADS = 0;
    private final int TAILS = 1;

    private int face;

    /**
     * 任何一个硬币都应该处于一个正反的位置上
     */
    public Coin () {
        flip();
    }

    /**
     * 仍硬币
     */
    public void flip () {
        face = (int) (Math.random() * 2);
    }

    /**
     * 判断是否是上
     * @return 上
     */
    public boolean isHeads() {
        return face == HEADS;
    }

    @Override
    public String toString() {
        String faceName;
        if (face == HEADS) {
            faceName = "Heads";
        } else {
            faceName = "Tails";
        }
        return faceName;
    }

    @Test
    public void coinTest() {
        Coin coin = new Coin();
        System.out.println(coin);
    }
}

```

常量HEADS和TAILS和变量face的声明是在类的内部，确保每个硬币都有自己的face。

对于初始化的变量，可以将其进行明确的初始化（在构造函数中），这样有助于阅读。

protected只能在继承关系中使用。

在类的内部创建私有方法（支持方法）来帮助其他方法完成其工作，这是一种好习惯，拆分方法复杂度，便于阅读。

类的内部常量可以设置为public + final，只要无法被外部更改，保持封装原则即可。可以被访问，但无法被修改。

谨慎的设置getter和setter，虽然为了方便（下图的冲突封装，其实并不全是，也有可能是常量类）

finalize方法定义在类内部，返回void，在GC执行之前执行，可以用来完成GC不会处理的活动（如，关闭文件）

将对象作为方法参数传递时，方法的对象参数仍然指向调用之前对象引用，和值传递不同。

static静态变量由类的所有实例共享。所以通常也会被final修饰

> 注意静态方法中不能访问非静态变量，换句话说只能访问静态变量和局部变量。所以工具类的方法一般都是静态的。


